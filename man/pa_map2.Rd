% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map2_family.R, R/pmap_family.R
\name{pa_map2}
\alias{pa_map2}
\alias{pa_map2_lgl}
\alias{pa_map2_int}
\alias{pa_map2_dbl}
\alias{pa_map2_chr}
\alias{pa_map2_df}
\alias{pa_map2_dfr}
\alias{pa_map2_dfc}
\alias{pa_pmap}
\alias{pa_pmap_lgl}
\alias{pa_pmap_int}
\alias{pa_pmap_dbl}
\alias{pa_pmap_chr}
\alias{pa_pmap_df}
\alias{pa_pmap_dfr}
\alias{pa_pmap_dfc}
\alias{pa_pwalk}
\title{Parallel Version of purrr map2 family}
\usage{
pa_map2(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_lgl(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_int(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_dbl(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_chr(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_df(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_dfr(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map2_dfc(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_lgl(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_int(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_dbl(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_chr(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_df(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_dfr(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pmap_dfc(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_pwalk(
  .l,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)
}
\arguments{
\item{.x}{Vectors of the same length. A vector of length 1 will
be recycled.}

\item{.y}{Vectors of the same length. A vector of length 1 will
be recycled.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{cores}{(Optional) Number of cores (i.e. workers) to be used. The
default value is: Available CPU cores - 1}

\item{adaptor}{The foreach adaptor to be used. Available options are:
\itemize{
\item "doParallel" (default)
\item "doFuture"
\item "doMC"
\item "doMPI"
\item "doSNOW"}}

\item{cluster_type}{The Clusters architecture to be used with the selected
adaptor. Note that allowed values for this argument depends on the
"adaptor" argument: \enumerate{
\item If adaptor is "doParallel":
  \itemize{
    \item in windows OS: "PSOCK" (default for Windows)
    \item in Unix-based OS: "FORK" (default for Unix), "PSOCK"
    }
\item If adaptor is "doFuture":
  \itemize{
  \item in windows OS: "multisession" (default for Windows),
    "cluster_PSOCK"
  \item in Unix-based OS: "multicore" (default for Unix), "multisession",
    "cluster_FORK", "cluster_PSOCK"
  }
\item If adaptor is "doMC":
  \itemize{
    \item No cluster_type options here, let cluster_type be NULL
    }
\item If adaptor is "doMPI":
  \itemize{
    \item No cluster_type options here, let cluster_type be NULL
    }
\item If adaptor is "doSNOW":
  \itemize{
  \item in windows OS: "SOCK" (default for Windows)
  \item in Unix-based OS: "MPI" (default for Unix), "NWS", "SOCK"
  }
}}

\item{splitter}{(Optional) Explicitly instruct parapurrr how to pass
your input elements to the workers. Splitter should be alist where
each of its elements is a vector of integers or integer-like numbers
(i.e. no decimal points) of the indexes of your input elements.
Collectively they should have a one-to-one correspondence with .x
indexes. See the Vignettes for further explanation and examples.}

\item{auto_export}{(TRUE (default), FALSE or "all") Should parapurrr
export the detected objects used in .f, from the function's calling
frame to the workers? Default is set to TRUE for convenience, but to
improve the performance, consider turning  auto_export off and manually
supply the exported variables using .export argument.  "all" is the
most conservative and yet, potentially resource-demanding option. It
will clone the function's calling environment, and export every
variable to the workers, whether used or not.}

\item{.export}{character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in \code{NULL}.}

\item{.packages}{character vector of packages that the tasks depend on.
If \code{ex} requires a \code{R} package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with \verb{\%do\%}.}

\item{.noexport}{character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in \code{NULL}.}

\item{.errorhandling}{specifies how a task evaluation error should be handled.
If the value is "stop", then execution will be stopped via
the \code{stop} function if an error occurs.
If the value is "remove", the result for that task will not be
returned, or passed to the \code{.combine} function.
If it is "pass", then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is "stop".}

\item{.inorder}{logical flag indicating whether the \code{.combine}
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting \code{.inorder} to \code{FALSE} can give improved performance.
The default value is `TRUE.}

\item{.verbose}{logical flag enabling verbose messages.  This can be
very useful for trouble shooting.}

\item{.l}{A list of vectors, such as a data frame. The length of \code{.l}
determines the number of arguments that \code{.f} will be called with. List
names will be used if present.}
}
\value{
An atomic vector, list, or data frame, depending on the suffix.
Atomic vectors and lists will be named if \code{.x} or the first
element of \code{.l} is named.

If all input is length 0, the output will be length 0. If any
input is length 1, it will be recycled to the length of the longest.
}
\description{
The syntax and the logic of pa_map2 and pa_pmap family functions are
  identical to purrr's
  map functions. Please refer to \code{\link[purrr]{map2}} if you are not
  familiar with purrr mapping style. Except .x, .y or .l, and .f, other
  arguments are optional and control the parallelization processes.
}
\details{
Note that except cores, cluster_type, adaptor, auto_export, and splitter,
  documentation of other arguments, return section, and examples section
  are automatically imported from
  \href{https://cran.r-project.org/package=purrr}{purrr} and
  \href{https://cran.r-project.org/package=foreach}{foreach} packages.
}
