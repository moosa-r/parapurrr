% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/imap_family.R
\name{pa_imap}
\alias{pa_imap}
\alias{pa_imap_lgl}
\alias{pa_imap_int}
\alias{pa_imap_dbl}
\alias{pa_imap_chr}
\alias{pa_imap_df}
\alias{pa_imap_dfr}
\alias{pa_imap_dfc}
\title{Parallel Version of purrr imap family}
\usage{
pa_imap(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_lgl(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_int(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_dbl(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_chr(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_df(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_dfr(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_imap_dfc(
  .x,
  .f,
  cores = NULL,
  adaptor = "DoParallel",
  cluster_type = NULL,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{cores}{(optional) Number of cores (i.e. workers) to be used. Default
is: your computer CPU cores - 1}

\item{adaptor}{The foreeach adaptor to be used. Available options are:
"DoParallel" (default).}

\item{cluster_type}{The Clusters archetecture to be used with the selected
adaptor. Note that allowed values for this argument, depends on the
"adaptor" argument: \itemize{
\item if adaptor = "DoParallel":
  \enumerate{\item PSOCK (default for Windows)
             \item FORK (default for Unix)}
}}

\item{.export}{character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in \code{NULL}.}

\item{.packages}{character vector of packages that the tasks depend on.
If \code{ex} requires a \code{R} package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with \verb{\%do\%}.}

\item{.noexport}{character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in \code{NULL}.}

\item{.errorhandling}{specifies how a task evaluation error should be handled.
If the value is "stop", then execution will be stopped via
the \code{stop} function if an error occurs.
If the value is "remove", the result for that task will not be
returned, or passed to the \code{.combine} function.
If it is "pass", then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is "stop".}

\item{.inorder}{logical flag indicating whether the \code{.combine}
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting \code{.inorder} to \code{FALSE} can give improved performance.
The default value is `TRUE.}

\item{.verbose}{logical flag enabling verbose messages.  This can be
very useful for trouble shooting.}
}
\value{
A vector the same length as \code{.x}.
}
\description{
The syntax and the logic of pa_imap* functions are the identical to purrr's
  map functions. Please refer to \code{\link[purrr]{imap}} if you are not
  familiar with purrr mapping style. Except .x and .y, other arguments are
  optional and control the parallelization processes. They will be handled
  to foreeach function and the selected forreach adaptor.
}
\details{
Note that except cores, cluster_type, and adaptor, documentation of other
  arguments, return section, and examples section are automatically imported
  from purrr and foreach packages.
}
