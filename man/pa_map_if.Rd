% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map_if_at.R
\name{pa_map_if}
\alias{pa_map_if}
\alias{pa_map_at}
\title{Parallel Version of purrr map_if and map_at function}
\usage{
pa_map_if(
  .x,
  .p,
  ...,
  .f,
  .else = NULL,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)

pa_map_at(
  .x,
  .at,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.p}{A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as \code{.x}.
Alternatively, if the elements of \code{.x} are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where \code{.p} evaluates to
\code{TRUE} will be modified.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{.else}{A function applied to elements of \code{.x} for which \code{.p}
returns \code{FALSE}.}

\item{cores}{(Optional) Number of cores (i.e. workers) to be used. The
default value is: Available CPU cores - 1}

\item{adaptor}{The foreach adaptor to be used. Available options are:
\itemize{
\item "doParallel" (default)
\item "doFuture"
\item "doMC"
\item "doMPI"
\item "doSNOW"}}

\item{cluster_type}{The Clusters architecture to be used with the selected
adaptor. Note that allowed values for this argument depends on the
"adaptor" argument: \enumerate{
\item If adaptor is "doParallel":
  \itemize{
    \item in windows OS: "PSOCK" (default for Windows)
    \item in Unix-based OS: "FORK" (default for Unix), "PSOCK"
    }
\item If adaptor is "doFuture":
  \itemize{
  \item in windows OS: "multisession" (default for Windows),
    "cluster_PSOCK"
  \item in Unix-based OS: "multicore" (default for Unix), "multisession",
    "cluster_FORK", "cluster_PSOCK"
  }
\item If adaptor is "doMC":
  \itemize{
    \item No cluster_type options here, let cluster_type be NULL
    }
\item If adaptor is "doMPI":
  \itemize{
    \item No cluster_type options here, let cluster_type be NULL
    }
\item If adaptor is "doSNOW":
  \itemize{
  \item in windows OS: "SOCK" (default for Windows)
  \item in Unix-based OS: "MPI" (default for Unix), "SOCK"
  }
}}

\item{splitter}{(Optional) Explicitly instruct parapurrr how to pass
your input elements to the workers. Splitter should be alist where
each of its elements is a vector of integers or integer-like numbers
(i.e. no decimal points) of the indexes of your input elements.
Collectively they should have a one-to-one correspondence with .x
indexes. See the Vignettes for further explanation and examples.}

\item{auto_export}{(TRUE (default), FALSE or "all") Should parapurrr
export the detected objects used in .f, from the function's calling
frame to the workers? Default is set to TRUE for convenience, but to
improve the performance, consider turning  auto_export off and manually
supply the exported variables using .export argument.  "all" is the
most conservative and yet, potentially resource-demanding option. It
will clone the function's calling environment, and export every
variable to the workers, whether used or not.}

\item{.export}{character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in \code{NULL}.}

\item{.packages}{character vector of packages that the tasks depend on.
If \code{ex} requires a \code{R} package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with \verb{\%do\%}.}

\item{.noexport}{character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in \code{NULL}.}

\item{.errorhandling}{specifies how a task evaluation error should be handled.
If the value is "stop", then execution will be stopped via
the \code{stop} function if an error occurs.
If the value is "remove", the result for that task will not be
returned, or passed to the \code{.combine} function.
If it is "pass", then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is "stop".}

\item{.inorder}{logical flag indicating whether the \code{.combine}
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting \code{.inorder} to \code{FALSE} can give improved performance.
The default value is `TRUE.}

\item{.verbose}{logical flag enabling verbose messages.  This can be
very useful for trouble shooting.}

\item{.at}{A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to \code{.at} will be modified.
If the \code{tidyselect} package is installed, you can use \code{vars()} and
the \code{tidyselect} helpers to select elements.}
}
\description{
The syntax and the logic of pa_map_if and pa_map_at functions are
  identical to purrr's map_if and map_at
  functions. Please refer to \code{\link[purrr]{map_if}} if you are not
  familiar with purrr mapping style. Except .x, .f, and .p or .at other
  arguments are  optional and control the parallelization processes.
}
\details{
Note that except cores, cluster_type, adaptor, auto_export, and splitter,
  documentation of other arguments, return section, and examples section
  are automatically imported from
  \href{https://cran.r-project.org/package=purrr}{purrr} and
  \href{https://cran.r-project.org/package=foreach}{foreach} packages.
}
