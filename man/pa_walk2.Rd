% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/walk_family.R
\name{pa_walk2}
\alias{pa_walk2}
\title{Parallel Version of purrr walk2 function}
\usage{
pa_walk2(
  .x,
  .y,
  .f,
  ...,
  cores = NULL,
  adaptor = "doParallel",
  cluster_type = NULL,
  splitter = NULL,
  auto_export = TRUE,
  .export = NULL,
  .packages = NULL,
  .noexport = NULL,
  .errorhandling = "stop",
  .inorder = TRUE,
  .verbose = FALSE
)
}
\arguments{
\item{.x}{Vectors of the same length. A vector of length 1 will
be recycled.}

\item{.y}{Vectors of the same length. A vector of length 1 will
be recycled.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{cores}{(optional) Number of cores (i.e. workers) to be used. Default
is: your computer CPU cores - 1}

\item{adaptor}{The foreach adaptor to be used. Available options are:
\itemize{\item "doParallel" (default) \item "doMPI" \item "doSNOW"
\item "doFuture"}}

\item{cluster_type}{The Clusters architecture to be used with the selected
adaptor. Note that allowed values for this argument depends on the
"adaptor" argument: \enumerate{
\item if adaptor is doParallel":
  \itemize{
    \item in windows OS: "PSOCK" (default for Windows)
    \item in Unix-based OS: "FORK" (default for Unix), "PSOCK"
    }
\item if adaptor is doMPI:
  \itemize{
    \item No cluster_type options here, let cluster_type be NULL
    }
\item if adaptor is "doSNOW":
  \itemize{
  \item in windows OS: "SOCK" (default for Windows)
  \item in Unix-based OS: "MPI" (default for Unix), "NWS", "SOCK"
  }
\item if adaptor is "doFuture":
  \itemize{
  \item in windows OS: "multisession" (default for Windows),
    "cluster_PSOCK"
  \item in Unix-based OS: "multicore" (default for Unix), "multisession",
    "cluster_FORK", "cluster_PSOCK"
  }
}}

\item{splitter}{(optional) Use this argument to instruct parapurrr how to
handle your input elements to the available cores. The Splitter is a
list where each of its elements is a numeric vector. Each numeric vector
corresponds to a core, and the elements of each vector should be indexes
of .x input's elements; Collectively they should have a one-to-one
correspondence with .x indexes. See the Vignettes for further explanations
and examples.}

\item{auto_export}{(default = TRUE) Should variables in the function's
calling environment be exported to workers? Default is set to TRUE for
convenience; But to improve the performance, consider turning auto_export
off and manually setting the exported variables using .export argument.}

\item{.export}{character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in \code{NULL}.}

\item{.packages}{character vector of packages that the tasks depend on.
If \code{ex} requires a \code{R} package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with \verb{\%do\%}.}

\item{.noexport}{character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in \code{NULL}.}

\item{.errorhandling}{specifies how a task evaluation error should be handled.
If the value is "stop", then execution will be stopped via
the \code{stop} function if an error occurs.
If the value is "remove", the result for that task will not be
returned, or passed to the \code{.combine} function.
If it is "pass", then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is "stop".}

\item{.inorder}{logical flag indicating whether the \code{.combine}
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting \code{.inorder} to \code{FALSE} can give improved performance.
The default value is `TRUE.}

\item{.verbose}{logical flag enabling verbose messages.  This can be
very useful for trouble shooting.}
}
\value{
An atomic vector, list, or data frame, depending on the suffix.
Atomic vectors and lists will be named if \code{.x} or the first
element of \code{.l} is named.

If all input is length 0, the output will be length 0. If any
input is length 1, it will be recycled to the length of the longest.
}
\description{
The syntax and the logic of pa_walk functions are the identical to purrr's
  walk function. Please refer to \code{\link[purrr]{map2}} if you are not
  familiar with purrr mapping style. Except .x, .y, .f, other arguments are
  optional and control the parallelization processes. They will be handled
  to foreach function and the selected forreach adaptor.
}
\details{
Note that except cores, cluster_type, and adaptor, documentation of other
  arguments, return section, and examples section are automatically imported
  from purrr and foreach packages.
}
